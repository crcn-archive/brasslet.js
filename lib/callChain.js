// Generated by CoffeeScript 1.7.0
var CallChain, async, events, flatstack, flatten, toarray,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

flatstack = require("flatstack");

events = require("events");

async = require("async");

toarray = require("toarray");

flatten = require("flatten");

CallChain = (function(_super) {
  __extends(CallChain, _super);


  /*
   */

  function CallChain(options) {
    this._error = __bind(this._error, this);
    this.limit = __bind(this.limit, this);
    this.filter = __bind(this.filter, this);
    var methodName;
    this._delay = -1;
    this.fasten = options.fasten, this.methods = options.methods, this.type = options.type, this.callstack = options.callstack;
    this._target(options.target);
    for (methodName in this.methods) {
      this._addMethod(methodName, this.methods[methodName]);
    }
    this.on("error", function() {});
  }


  /*
   */

  CallChain.prototype._addMethod = function(name, options) {
    var map, onCall, onResult, type;
    type = options.type || this.type;
    map = options.map || function(result) {
      return result;
    };
    onResult = options.onResult || function() {};
    onCall = options.onCall || function() {};
    return this[name] = (function(_this) {
      return function() {
        var args, callChain;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        callChain = _this.fasten.wrap(type, void 0, _this.callstack);
        callChain.parent = _this;
        _this.callstack.push(function(next) {
          return setTimeout((function() {
            var fn;
            if (_this.__err) {
              callChain.__err = _this.__err;
              return next();
            }
            fn = _this._parallel ? async.map : async.mapSeries;
            return fn.call(async, _this.target, (function(target, next) {
              var call;
              _this._bubble("call", {
                chain: _this,
                type: _this.type,
                method: name,
                target: target,
                args: args
              });
              onCall.call(_this, target);
              call = options.call || target[name];
              return call.apply(target, args.concat(function(err, result) {
                var v;
                if (err != null) {
                  return next(err);
                }
                _this._bubble("result", {
                  chain: _this,
                  type: _this.type,
                  target: target,
                  method: name,
                  data: result,
                  args: args
                });
                onResult.call(_this, result);
                v = map.call(target, result);
                if (~_this._delay) {
                  return setTimeout(next, _this._delay, null, v);
                } else {
                  return next(null, v);
                }
              }));
            }), function(err, newTarget) {
              callChain.__err = err;
              if (err) {
                _this._error(err);
              } else {
                callChain._target(flatten(newTarget));
              }
              return next();
            });
          }), 1);
        });
        return callChain;
      };
    })(this);
  };


  /*
   */

  CallChain.prototype._target = function(target) {
    var targets;
    targets = toarray(target).filter((function(_this) {
      return function(target) {
        if (!_this._filter) {
          return true;
        }
        return _this._filter(target);
      };
    })(this));
    if (this._limit != null) {
      targets = targets.slice(0, this._limit);
    }
    return this.target = targets;
  };


  /*
   */

  CallChain.prototype.count = function() {
    return this.then((function(_this) {
      return function(err, targets) {
        return _this.target = [targets.length];
      };
    })(this));
  };


  /*
   */

  CallChain.prototype.series = function() {
    this._parallel = false;
    return this;
  };


  /*
   */

  CallChain.prototype.parallel = function() {
    this._parallel = true;
    return this;
  };


  /*
   */

  CallChain.prototype.delay = function(value) {
    this._delay = value;
    return this;
  };


  /*
   */

  CallChain.prototype.detach = function() {
    this.callstack = flatstack();
    return this;
  };


  /*
   */

  CallChain.prototype.filter = function(value) {
    this._filter = value;
    return this;
  };


  /*
   */

  CallChain.prototype.limit = function(count) {
    this._limit = count;
    return this;
  };


  /*
   */

  CallChain.prototype.one = function() {
    return this.limit(1);
  };


  /*
   */

  CallChain.prototype.root = function() {
    var p;
    p = this;
    while (p.parent) {
      p = p.parent;
    }
    return p;
  };


  /*
   */

  CallChain.prototype.bubble = function() {
    var _ref;
    this.emit.apply(this, arguments);
    return (_ref = this.parent) != null ? _ref.bubble.apply(_ref, arguments) : void 0;
  };


  /*
   */

  CallChain.prototype._bubble = function() {
    var _ref;
    (_ref = this.fasten).emit.apply(_ref, arguments);
    return this.bubble.apply(this, arguments);
  };


  /*
   */

  CallChain.prototype.then = function(next) {
    this.callstack.push((function(_this) {
      return function() {
        var e;
        try {
          return next.call(_this.target, _this.__err, _this.target);
        } catch (_error) {
          e = _error;
          return _this.__err = e;
        }
      };
    })(this));
    return this;
  };


  /*
   */

  CallChain.prototype._error = function(err) {
    this.__err = err;
    return this.emit("error", err);
  };

  return CallChain;

})(events.EventEmitter);

module.exports = CallChain;
